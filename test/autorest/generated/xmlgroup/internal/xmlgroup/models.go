// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package xmlgroup

import (
	"encoding/xml"
	"fmt"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

type AccessTier string

const (
	AccessTierArchive AccessTier = "Archive"
	AccessTierCool    AccessTier = "Cool"
	AccessTierHot     AccessTier = "Hot"
	AccessTierP10     AccessTier = "P10"
	AccessTierP20     AccessTier = "P20"
	AccessTierP30     AccessTier = "P30"
	AccessTierP4      AccessTier = "P4"
	AccessTierP40     AccessTier = "P40"
	AccessTierP50     AccessTier = "P50"
	AccessTierP6      AccessTier = "P6"
)

func PossibleAccessTierValues() []AccessTier {
	return []AccessTier{AccessTierArchive, AccessTierCool, AccessTierHot, AccessTierP10, AccessTierP20, AccessTierP30, AccessTierP4, AccessTierP40, AccessTierP50, AccessTierP6}
}

type ArchiveStatus string

const (
	ArchiveStatusRehydratePendingToCool ArchiveStatus = "rehydrate-pending-to-cool"
	ArchiveStatusRehydratePendingToHot  ArchiveStatus = "rehydrate-pending-to-hot"
)

func PossibleArchiveStatusValues() []ArchiveStatus {
	return []ArchiveStatus{ArchiveStatusRehydratePendingToCool, ArchiveStatusRehydratePendingToHot}
}

type BlobType string

const (
	BlobTypeBlockblob  BlobType = "BlockBlob"
	BlobTypePageblob   BlobType = "PageBlob"
	BlobTypeAppendblob BlobType = "AppendBlob"
)

func PossibleBlobTypeValues() []BlobType {
	return []BlobType{BlobTypeBlockblob, BlobTypePageblob, BlobTypeAppendblob}
}

type CopyStatusType string

const (
	CopyStatusTypePending CopyStatusType = "pending"
	CopyStatusTypeSuccess CopyStatusType = "success"
	CopyStatusTypeAborted CopyStatusType = "aborted"
	CopyStatusTypeFailed  CopyStatusType = "failed"
)

func PossibleCopyStatusTypeValues() []CopyStatusType {
	return []CopyStatusType{CopyStatusTypePending, CopyStatusTypeSuccess, CopyStatusTypeAborted, CopyStatusTypeFailed}
}

type LeaseDurationType string

const (
	LeaseDurationTypeInfinite LeaseDurationType = "infinite"
	LeaseDurationTypeFixed    LeaseDurationType = "fixed"
)

func PossibleLeaseDurationTypeValues() []LeaseDurationType {
	return []LeaseDurationType{LeaseDurationTypeInfinite, LeaseDurationTypeFixed}
}

type LeaseStateType string

const (
	LeaseStateTypeAvailable LeaseStateType = "available"
	LeaseStateTypeLeased    LeaseStateType = "leased"
	LeaseStateTypeExpired   LeaseStateType = "expired"
	LeaseStateTypeBreaking  LeaseStateType = "breaking"
	LeaseStateTypeBroken    LeaseStateType = "broken"
)

func PossibleLeaseStateTypeValues() []LeaseStateType {
	return []LeaseStateType{LeaseStateTypeAvailable, LeaseStateTypeLeased, LeaseStateTypeExpired, LeaseStateTypeBreaking, LeaseStateTypeBroken}
}

type LeaseStatusType string

const (
	LeaseStatusTypeLocked   LeaseStatusType = "locked"
	LeaseStatusTypeUnlocked LeaseStatusType = "unlocked"
)

func PossibleLeaseStatusTypeValues() []LeaseStatusType {
	return []LeaseStatusType{LeaseStatusTypeLocked, LeaseStatusTypeUnlocked}
}

type PublicAccessType string

const (
	PublicAccessTypeBlob      PublicAccessType = "blob"
	PublicAccessTypeContainer PublicAccessType = "container"
)

func PossiblePublicAccessTypeValues() []PublicAccessType {
	return []PublicAccessType{PublicAccessTypeBlob, PublicAccessTypeContainer}
}

func (c PublicAccessType) ToPtr() *PublicAccessType {
	return &c
}

// An Access policy
type AccessPolicy struct {
	// the date-time the policy expires
	Expiry *time.Time `xml:"Expiry"`
	// the permissions for the acl policy
	Permission *string `xml:"Permission"`
	// the date-time the policy is active
	Start *time.Time `xml:"Start"`
}

// A barrel of apples.
type AppleBarrel struct {
	BadApples  *[]string `xml:"BadApples>Apple"`
	GoodApples *[]string `xml:"GoodApples>Apple"`
}

// A banana.
type Banana struct {
	// The time at which you should reconsider eating this banana
	Expiration *time.Time `xml:"expiration"`
	Flavor     *string    `xml:"flavor"`
	Name       *string    `xml:"name"`
}

// An Azure Storage blob
type Blob struct {
	Deleted *bool `xml:"Deleted"`
	// Dictionary of <paths·xml-headers·get·responses·200·headers·custom_header·schema>
	Metadata *map[string]*string `xml:"string"`
	Name     *string             `xml:"Name"`
	// Properties of a blob
	Properties *BlobProperties `xml:"Properties"`
	Snapshot   *string         `xml:"Snapshot"`
}

type BlobPrefix struct {
	Name *string `xml:"Name"`
}

// Properties of a blob
type BlobProperties struct {
	AccessTier         *AccessTier    `xml:"AccessTier"`
	AccessTierInferred *bool          `xml:"AccessTierInferred"`
	ArchiveStatus      *ArchiveStatus `xml:"ArchiveStatus"`
	BlobSequenceNumber *int32         `xml:"x-ms-blob-sequence-number"`
	BlobType           *BlobType      `xml:"BlobType"`
	CacheControl       *string        `xml:"Cache-Control"`
	ContentDisposition *string        `xml:"Content-Disposition"`
	ContentEncoding    *string        `xml:"Content-Encoding"`
	ContentLanguage    *string        `xml:"Content-Language"`
	// Size in bytes
	ContentLength          *int64             `xml:"Content-Length"`
	ContentMd5             *string            `xml:"Content-MD5"`
	ContentType            *string            `xml:"Content-Type"`
	CopyCompletionTime     *time.Time         `xml:"CopyCompletionTime"`
	CopyID                 *string            `xml:"CopyId"`
	CopyProgress           *string            `xml:"CopyProgress"`
	CopySource             *string            `xml:"CopySource"`
	CopyStatus             *CopyStatusType    `xml:"CopyStatus"`
	CopyStatusDescription  *string            `xml:"CopyStatusDescription"`
	DeletedTime            *time.Time         `xml:"DeletedTime"`
	DestinationSnapshot    *string            `xml:"DestinationSnapshot"`
	Etag                   *string            `xml:"Etag"`
	IncrementalCopy        *bool              `xml:"IncrementalCopy"`
	LastModified           *time.Time         `xml:"Last-Modified"`
	LeaseDuration          *LeaseDurationType `xml:"LeaseDuration"`
	LeaseState             *LeaseStateType    `xml:"LeaseState"`
	LeaseStatus            *LeaseStatusType   `xml:"LeaseStatus"`
	RemainingRetentionDays *int32             `xml:"RemainingRetentionDays"`
	ServerEncrypted        *bool              `xml:"ServerEncrypted"`
}

type Blobs struct {
	Blob       *[]Blob       `xml:"Blob"`
	BlobPrefix *[]BlobPrefix `xml:"BlobPrefix"`
}

// I am a complex type with no XML node
type ComplexTypeNoMeta struct {
	// The id of the res
	ID *string `xml:"ID"`
}

// I am a complex type with XML node
type ComplexTypeWithMeta struct {
	// The id of the res
	ID *string `xml:"ID"`
}

// An Azure Storage container
type Container struct {
	// Dictionary of <paths·xml-headers·get·responses·200·headers·custom_header·schema>
	Metadata *map[string]*string `xml:"string"`
	Name     *string             `xml:"Name"`
	// Properties of a container
	Properties *ContainerProperties `xml:"Properties"`
}

// Properties of a container
type ContainerProperties struct {
	Etag          *string            `xml:"Etag"`
	LastModified  *time.Time         `xml:"Last-Modified"`
	LeaseDuration *LeaseDurationType `xml:"LeaseDuration"`
	LeaseState    *LeaseStateType    `xml:"LeaseState"`
	LeaseStatus   *LeaseStatusType   `xml:"LeaseStatus"`
	PublicAccess  *PublicAccessType  `xml:"PublicAccess"`
}

func (c *ContainerProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type alias ContainerProperties
	aux := &struct {
		*alias
		LastModified *string `xml:"Last-Modified"`
	}{
		alias: (*alias)(c),
	}
	if err := d.DecodeElement(aux, &start); err != nil {
		return err
	}
	if aux.LastModified != nil {
		t, err := time.Parse(time.RFC1123, *aux.LastModified)
		if err != nil {
			return err
		}
		c.LastModified = &t
	}
	return nil
}

// CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain.
// Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in
// a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain
type CorsRule struct {
	// the request headers that the origin domain may specify on the CORS request.
	AllowedHeaders *string `xml:"AllowedHeaders"`
	// The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated)
	AllowedMethods *string `xml:"AllowedMethods"`
	// The origin domains that are permitted to make a request against the storage service via CORS. The origin domain is the
	// domain from which the request originates. Note that the origin must be an exact case-sensitive match with the origin that
	// the user age sends to the service. You can also use the wildcard character '*' to allow all origin domains to make requests
	// via CORS.
	AllowedOrigins *string `xml:"AllowedOrigins"`
	// The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer
	ExposedHeaders *string `xml:"ExposedHeaders"`
	// The maximum amount time that a browser should cache the preflight OPTIONS request.
	MaxAgeInSeconds *int32 `xml:"MaxAgeInSeconds"`
}

type Error struct {
	Message *string `xml:"message"`
	Status  *int32  `xml:"status"`
}

func newError(resp *azcore.Response) error {
	err := Error{}
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return err
}

func (e Error) Error() string {
	msg := ""
	if e.Message != nil {
		msg += fmt.Sprintf("Message: %v\n", *e.Message)
	}
	if e.Status != nil {
		msg += fmt.Sprintf("Status: %v\n", *e.Status)
	}
	if msg == "" {
		msg = "missing error info"
	}
	return msg
}

type JSONInput struct {
	ID *int32 `json:"id,omitempty"`
}

type JSONOutput struct {
	ID *int32 `json:"id,omitempty"`
}

// An enumeration of blobs
type ListBlobsResponse struct {
	Blobs           *Blobs  `xml:"Blobs"`
	ContainerName   *string `xml:"ContainerName,attr"`
	Delimiter       *string `xml:"Delimiter"`
	Marker          *string `xml:"Marker"`
	MaxResults      *int32  `xml:"MaxResults"`
	NextMarker      *string `xml:"NextMarker"`
	Prefix          *string `xml:"Prefix"`
	ServiceEndpoint *string `xml:"ServiceEndpoint,attr"`
}

// An enumeration of containers
type ListContainersResponse struct {
	Containers      *[]Container `xml:"Containers>Container"`
	Marker          *string      `xml:"Marker"`
	MaxResults      *int32       `xml:"MaxResults"`
	NextMarker      *string      `xml:"NextMarker"`
	Prefix          *string      `xml:"Prefix"`
	ServiceEndpoint *string      `xml:"ServiceEndpoint,attr"`
}

// Azure Analytics Logging settings.
type Logging struct {
	// Indicates whether all delete requests should be logged.
	Delete *bool `xml:"Delete"`
	// Indicates whether all read requests should be logged.
	Read *bool `xml:"Read"`
	// the retention policy
	RetentionPolicy *RetentionPolicy `xml:"RetentionPolicy"`
	// The version of Storage Analytics to configure.
	Version *string `xml:"Version"`
	// Indicates whether all write requests should be logged.
	Write *bool `xml:"Write"`
}

type Metrics struct {
	// Indicates whether metrics are enabled for the Blob service.
	Enabled *bool `xml:"Enabled"`
	// Indicates whether metrics should generate summary statistics for called API operations.
	IncludeApIs *bool `xml:"IncludeAPIs"`
	// the retention policy
	RetentionPolicy *RetentionPolicy `xml:"RetentionPolicy"`
	// The version of Storage Analytics to configure.
	Version *string `xml:"Version"`
}

// the retention policy
type RetentionPolicy struct {
	// Indicates the number of days that metrics or logging or soft-deleted data should be retained. All data older than this
	// value will be deleted
	Days *int32 `xml:"Days"`
	// Indicates whether a retention policy is enabled for the storage service
	Enabled *bool `xml:"Enabled"`
}

// I am root, and I ref a model WITH meta
type RootWithRefAndMeta struct {
	// I am a complex type with XML node
	RefToModel *ComplexTypeWithMeta `xml:"XMLComplexTypeWithMeta"`
	// Something else (just to avoid flattening)
	Something *string `xml:"Something"`
}

// I am root, and I ref a model with no meta
type RootWithRefAndNoMeta struct {
	// I am a complex type with no XML node
	RefToModel *ComplexTypeNoMeta `xml:"RefToModel"`
	// Something else (just to avoid flattening)
	Something *string `xml:"Something"`
}

// signed identifier
type SignedIDentifier struct {
	// An Access policy
	AccessPolicy *AccessPolicy `xml:"AccessPolicy"`
	// a unique id
	ID *string `xml:"Id"`
}

// A slide in a slideshow
type Slide struct {
	Items *[]string `xml:"item"`
	Title *string   `xml:"title"`
	Type  *string   `xml:"type,attr"`
}

// Data about a slideshow
type Slideshow struct {
	Author *string  `xml:"author,attr"`
	Date   *string  `xml:"date,attr"`
	Slides *[]Slide `xml:"slide"`
	Title  *string  `xml:"title,attr"`
}

// Storage Service Properties.
type StorageServiceProperties struct {
	// The set of CORS rules.
	Cors *[]CorsRule `xml:"Cors>CorsRule"`
	// The default version to use for requests to the Blob service if an incoming request's version is not specified. Possible
	// values include version 2008-10-27 and all more recent versions
	DefaultServiceVersion *string `xml:"DefaultServiceVersion"`
	// the retention policy
	DeleteRetentionPolicy *RetentionPolicy `xml:"DeleteRetentionPolicy"`
	HourMetrics           *Metrics         `xml:"HourMetrics"`
	// Azure Analytics Logging settings.
	Logging       *Logging `xml:"Logging"`
	MinuteMetrics *Metrics `xml:"MinuteMetrics"`
}

// XMLGetACLsResponse contains the response from method XML.GetACLs.
type XMLGetACLsResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
	// a collection of signed identifiers
	SignedIdentifiers *[]SignedIDentifier `xml:"SignedIdentifier"`
}

// XMLGetComplexTypeRefNoMetaResponse contains the response from method XML.GetComplexTypeRefNoMeta.
type XMLGetComplexTypeRefNoMetaResponse struct {
	// I am root, and I ref a model with no meta
	RootWithRefAndNoMeta *RootWithRefAndNoMeta
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetComplexTypeRefWithMetaResponse contains the response from method XML.GetComplexTypeRefWithMeta.
type XMLGetComplexTypeRefWithMetaResponse struct {
	// I am root, and I ref a model WITH meta
	RootWithRefAndMeta *RootWithRefAndMeta
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetEmptyChildElementResponse contains the response from method XML.GetEmptyChildElement.
type XMLGetEmptyChildElementResponse struct {
	// A banana.
	Banana *Banana
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetEmptyListResponse contains the response from method XML.GetEmptyList.
type XMLGetEmptyListResponse struct {
	// Data about a slideshow
	Slideshow *Slideshow
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetEmptyRootListResponse contains the response from method XML.GetEmptyRootList.
type XMLGetEmptyRootListResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
	Bananas    *[]Banana `xml:"banana"`
}

// XMLGetEmptyWrappedListsResponse contains the response from method XML.GetEmptyWrappedLists.
type XMLGetEmptyWrappedListsResponse struct {
	// A barrel of apples.
	AppleBarrel *AppleBarrel
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetHeadersResponse contains the response from method XML.GetHeaders.
type XMLGetHeadersResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetRootListResponse contains the response from method XML.GetRootList.
type XMLGetRootListResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
	Bananas    *[]Banana `xml:"banana"`
}

// XMLGetRootListSingleItemResponse contains the response from method XML.GetRootListSingleItem.
type XMLGetRootListSingleItemResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
	Bananas    *[]Banana `xml:"banana"`
}

// XMLGetServicePropertiesResponse contains the response from method XML.GetServiceProperties.
type XMLGetServicePropertiesResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
	// Storage Service Properties.
	StorageServiceProperties *StorageServiceProperties
}

// XMLGetSimpleResponse contains the response from method XML.GetSimple.
type XMLGetSimpleResponse struct {
	// Data about a slideshow
	Slideshow *Slideshow
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLGetWrappedListsResponse contains the response from method XML.GetWrappedLists.
type XMLGetWrappedListsResponse struct {
	// A barrel of apples.
	AppleBarrel *AppleBarrel
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLJSONInputResponse contains the response from method XML.JSONInput.
type XMLJSONInputResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLJSONOutputResponse contains the response from method XML.JSONOutput.
type XMLJSONOutputResponse struct {
	JSONOutput *JSONOutput
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLListBlobsResponse contains the response from method XML.ListBlobs.
type XMLListBlobsResponse struct {
	// An enumeration of blobs
	ListBlobsResponse *ListBlobsResponse
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLListContainersResponse contains the response from method XML.ListContainers.
type XMLListContainersResponse struct {
	// An enumeration of containers
	ListContainersResponse *ListContainersResponse
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutACLsResponse contains the response from method XML.PutACLs.
type XMLPutACLsResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutComplexTypeRefNoMetaResponse contains the response from method XML.PutComplexTypeRefNoMeta.
type XMLPutComplexTypeRefNoMetaResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutComplexTypeRefWithMetaResponse contains the response from method XML.PutComplexTypeRefWithMeta.
type XMLPutComplexTypeRefWithMetaResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutEmptyChildElementResponse contains the response from method XML.PutEmptyChildElement.
type XMLPutEmptyChildElementResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutEmptyListResponse contains the response from method XML.PutEmptyList.
type XMLPutEmptyListResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutEmptyRootListResponse contains the response from method XML.PutEmptyRootList.
type XMLPutEmptyRootListResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutEmptyWrappedListsResponse contains the response from method XML.PutEmptyWrappedLists.
type XMLPutEmptyWrappedListsResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutRootListResponse contains the response from method XML.PutRootList.
type XMLPutRootListResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutRootListSingleItemResponse contains the response from method XML.PutRootListSingleItem.
type XMLPutRootListSingleItemResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutServicePropertiesResponse contains the response from method XML.PutServiceProperties.
type XMLPutServicePropertiesResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutSimpleResponse contains the response from method XML.PutSimple.
type XMLPutSimpleResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}

// XMLPutWrappedListsResponse contains the response from method XML.PutWrappedLists.
type XMLPutWrappedListsResponse struct {
	// StatusCode contains the HTTP status code.
	StatusCode int
}
